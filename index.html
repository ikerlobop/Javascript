<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lectura y Escritura PLC S7-1200 con Snap7</title>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 1rem 2rem;
        }
        h1, h2 {
            color: #2e3c59;
        }
        pre {
            background-color: #eee;
            padding: 1em;
            border-radius: 6px;
            overflow-x: auto;
        }
        .section {
            margin-bottom: 2rem;
        }
        .footer {
            text-align: center;
            font-size: 0.8rem;
            color: #666;
        }
    </style>
</head>
<body>

    <h1>Comunicaci√≥n Python - PLC Siemens con Snap7</h1>

    <div class="section">
        <h2>¬øQu√© vamos a aprender?</h2>
        <p>
            En esta pr√°ctica veremos c√≥mo usar una librer√≠a Python llamada <strong>Snap7</strong> para conectarnos
            a un PLC Siemens S7-1200, leer y escribir datos en un bloque de datos (DB) y trabajar con distintos tipos: enteros, reales y booleanos.
        </p>
    </div>

    <div class="section">
        <h2>üîå C√≥digo de Ejemplo</h2>
        <p>Este script conecta al PLC con IP <strong>192.168.0.100</strong>, accede al DB1 y permite modificar variables:</p>
        <pre><code>import snap7
from snap7.util import *
from snap7.type import Areas
import tkinter as tk
from tkinter import ttk

IP_PLC = "192.168.2.44"
DB_NUM = 1
DB_SIZE = 14

class PLCApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Interfaz PLC - Snap7")

        self.client = snap7.client.Client()
        try:
            self.client.connect(IP_PLC, 0, 1)
            if self.client.get_connected():
                print("‚úÖ Conectado al PLC")
        except Exception as e:
            print(f"‚ùå No se pudo conectar: {e}")
            return

        self.data = bytearray(DB_SIZE)

        # Static_1 (Int) - editable + lectura
        ttk.Label(root, text="Static_1 (Int)").grid(row=0, column=0, sticky="e", padx=5, pady=5)
        self.int_var = tk.StringVar()
        ttk.Entry(root, textvariable=self.int_var, width=10).grid(row=0, column=1)
        self.int_actual = tk.StringVar(value="---")
        ttk.Label(root, textvariable=self.int_actual).grid(row=0, column=2, padx=10)

        # Static_4 (Real) - slider + lectura
        ttk.Label(root, text="Static_4 (Real)").grid(row=1, column=0, sticky="e", padx=5, pady=5)
        self.temp_slider = ttk.Scale(root, from_=0, to=100, orient="horizontal", length=200, command=self.actualizar_valor_slider)
        self.temp_slider.grid(row=1, column=1)
        self.temp_actual = tk.StringVar(value="---")
        ttk.Label(root, textvariable=self.temp_actual).grid(row=1, column=2, padx=10)

        # Static_5 (Bool) - bot√≥n + color + lectura
        ttk.Label(root, text="Static_5 (Bool)").grid(row=2, column=0, sticky="e", padx=5, pady=5)
        self.estado_label = tk.Label(root, text="OFF", bg="red", width=10)
        self.estado_label.grid(row=2, column=1)
        ttk.Button(root, text="Cambiar Estado", command=self.toggle_estado).grid(row=2, column=2)
        self.bool_actual = tk.StringVar(value="---")
        ttk.Label(root, textvariable=self.bool_actual).grid(row=2, column=3)

        # Static_2, Static_3, Static_6 - solo lectura
        self.read_labels = {}
        for i, (name, row) in enumerate([
            ("Static_2 (Int)", 3),
            ("Static_3 (Real)", 4),
            ("Static_6 (Bool)", 5)
        ]):
            ttk.Label(root, text=name).grid(row=row, column=0, sticky="e", padx=5, pady=5)
            var = tk.StringVar(value="---")
            ttk.Label(root, textvariable=var).grid(row=row, column=1)
            self.read_labels[name] = var

        # Botones
        ttk.Button(root, text="Actualizar", command=self.actualizar_datos).grid(row=6, column=0, pady=10)
        ttk.Button(root, text="Enviar al PLC", command=self.enviar_datos).grid(row=6, column=1)

        self.estado_bool = False
        self.actualizar_datos()

    def leer_datos(self):
        self.data = self.client.read_area(Areas.DB, DB_NUM, 0, DB_SIZE)
        return self.data

    def enviar_datos(self):
        try:
            set_int(self.data, 0, int(self.int_var.get()))
            set_real(self.data, 8, self.temp_slider.get())
            set_bool(self.data, 12, 0, self.estado_bool)
            self.client.write_area(Areas.DB, DB_NUM, 0, self.data)
            print("üìù Datos escritos correctamente.")
        except Exception as e:
            print(f"‚ùå Error al enviar: {e}")

    def actualizar_datos(self):
        try:
            self.leer_datos()
            valor_int = get_int(self.data, 0)
            valor_real = get_real(self.data, 8)
            valor_bool = get_bool(self.data, 12, 0)

            self.int_var.set(str(valor_int))
            self.int_actual.set(f"Actual: {valor_int}")

            self.temp_slider.set(valor_real)
            self.temp_actual.set(f"{valor_real:.2f} ¬∫C")

            self.estado_bool = valor_bool
            self.bool_actual.set(f"{'ON' if valor_bool else 'OFF'}")
            self.actualizar_color_estado()

            self.read_labels["Static_2 (Int)"].set(str(get_int(self.data, 2)))
            self.read_labels["Static_3 (Real)"].set(f"{get_real(self.data, 4):.2f}")
            self.read_labels["Static_6 (Bool)"].set(str(get_bool(self.data, 12, 1)))
        except Exception as e:
            print(f"‚ùå Error al leer: {e}")

    def toggle_estado(self):
        self.estado_bool = not self.estado_bool
        self.actualizar_color_estado()

    def actualizar_color_estado(self):
        color = "green" if self.estado_bool else "red"
        text = "ON" if self.estado_bool else "OFF"
        self.estado_label.config(text=text, bg=color)

    def actualizar_valor_slider(self, value):
        self.temp_actual.set(f"{float(value):.2f} ¬∫C")

    def cerrar(self):
        self.client.disconnect()
        print("üîå Desconectado del PLC.")
        self.root.destroy()

if __name__ == "__main__":
    root = tk.Tk()
    app = PLCApp(root)
    root.protocol("WM_DELETE_WINDOW", app.cerrar)
    root.mainloop()


        </code></pre>
    </div>

    <div class="section">
        <h2>üí° Pistas</h2>
        <ul>
            <li>Se debe importar correctamente la librer√≠a Snap7.</li>
            <li>El acceso <strong>PUT/GET</strong> debe estar activado en el PLC.</li>
            <li>Los DB deben estar <strong>no optimizados</strong> para que las direcciones funcionen.</li>
            <li>Snap7 solo funciona con PLCs Siemens (S7-300/400/1200/1500).</li>
        
        </ul>
    </div>

    <div class="footer">
        P√°gina educativa elaborada por Iker Lobo P√©rez ‚Äì Formaci√≥n Industrial y Automatizaci√≥n ‚Äì 2025
    </div>

</body>
</html>
